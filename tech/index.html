<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>菜鸟的技术文档 | 974 的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/wxtouxiang.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.f766fcda.css" as="style"><link rel="preload" href="/assets/js/app.160748f8.js" as="script"><link rel="preload" href="/assets/js/2.c27d8c9e.js" as="script"><link rel="preload" href="/assets/js/6.7f9d2657.js" as="script"><link rel="prefetch" href="/assets/js/3.5a4fec31.js"><link rel="prefetch" href="/assets/js/4.341a5165.js"><link rel="prefetch" href="/assets/js/5.a374d118.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f766fcda.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/wxtouxiang.jpg" alt="974 的博客" class="logo"> <span class="site-name can-hide">974 的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tech/" class="nav-link router-link-exact-active router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/627904fdac31" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tech/" class="nav-link router-link-exact-active router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/627904fdac31" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>菜鸟的技术文档</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/#框架和库-插件-的区别" class="sidebar-link">框架和库(插件)的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#后端mvc和前端mvvm" class="sidebar-link">后端MVC和前端MVVM</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#vue基本代码" class="sidebar-link">Vue基本代码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#过滤器" class="sidebar-link">过滤器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#修饰符" class="sidebar-link">修饰符</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#自定义指令" class="sidebar-link">自定义指令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#生命周期函数-钩子-事件" class="sidebar-link">生命周期函数(钩子/事件)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/#实例创建阶段" class="sidebar-link">实例创建阶段:</a></li><li class="sidebar-sub-header"><a href="/tech/#实例运行阶段" class="sidebar-link">实例运行阶段:</a></li><li class="sidebar-sub-header"><a href="/tech/#实例销毁阶段" class="sidebar-link">实例销毁阶段:</a></li></ul></li><li><a href="/tech/#vue-resource实现get、post、jsonp请求" class="sidebar-link">vue-resource实现get、post、jsonp请求</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#过渡-动画" class="sidebar-link">过渡&amp;动画</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#vue组件" class="sidebar-link">Vue组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/#组件化与模块化的不同：" class="sidebar-link">组件化与模块化的不同：</a></li><li class="sidebar-sub-header"><a href="/tech/#创建组件的方法：" class="sidebar-link">创建组件的方法：</a></li><li class="sidebar-sub-header"><a href="/tech/#组件中的data：" class="sidebar-link">组件中的data：</a></li><li class="sidebar-sub-header"><a href="/tech/#多个组件的切换-过渡动画" class="sidebar-link">多个组件的切换&amp;过渡动画</a></li><li class="sidebar-sub-header"><a href="/tech/#父亲组件向子组件传值" class="sidebar-link">父亲组件向子组件传值</a></li></ul></li><li><a href="/tech/#vue内置组件" class="sidebar-link">Vue内置组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#使用ref获取dom元素和组件引用" class="sidebar-link">使用ref获取DOM元素和组件引用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#ue-router" class="sidebar-link">ue-router</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/#在vue中使用vue-router" class="sidebar-link">在vue中使用vue-router</a></li></ul></li><li><a href="/tech/#vue实例中的配置项" class="sidebar-link">vue实例中的配置项</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/#vuex" class="sidebar-link">VUEX</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="菜鸟的技术文档"><a href="#菜鸟的技术文档" class="header-anchor">#</a> 菜鸟的技术文档</h1> <h1 id="vue"><a href="#vue" class="header-anchor">#</a> VUE</h1> <hr> <h1 id="首先用引用官方的话来介绍vuejs："><a href="#首先用引用官方的话来介绍vuejs：" class="header-anchor">#</a> 首先用引用官方的话来介绍vuejs：</h1> <blockquote><p>Vue 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener noreferrer">现代化的工具链<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener noreferrer">支持类库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote> <blockquote><p>其实对vue基本的学习都可以在<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">vue官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>学到，这篇文章主要写的是我在学习vue时一些经历感想。</p></blockquote> <hr> <h2 id="框架和库-插件-的区别"><a href="#框架和库-插件-的区别" class="header-anchor">#</a> 框架和库(插件)的区别</h2> <ul><li>框架: 是一套完整的解决方案；对项目的入侵性较大，项目如果想更换框架，则需要重构整个项目；</li> <li>库(插件): 提供某一个小功能，对项目入侵性小，如果某个库无法满足项目需求，可以很容易到其他库实现；</li></ul> <hr> <h2 id="后端mvc和前端mvvm"><a href="#后端mvc和前端mvvm" class="header-anchor">#</a> 后端MVC和前端MVVM</h2> <ul><li>MVC是后端的分层概念：
M-----Modle层，主要处理数据的CRUD；
V-----视图层，主要为前端页面；
C-----逻辑层，主要为逻辑处理;
<img src="https://upload-images.jianshu.io/upload_images/17912672-00c72986bae4adda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVC"></li> <li>MVVM是前端图层的概念，主要关注于视图分层：
M-----Modle层，主要保存每个页面中单独的数据；
V-----View层，主要为每个页面HTML结构；
VM-----VM(ViewModel)层，主要为M和V之间的调度者，分隔M和V；
<img src="https://upload-images.jianshu.io/upload_images/17912672-5fce47d442d2a942.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVVM"></li></ul> <hr> <h2 id="vue基本代码"><a href="#vue基本代码" class="header-anchor">#</a> Vue基本代码</h2> <ol><li>项目中需要创建一个lib类库,存放vue文件;</li> <li>html中引入vue文件；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;
&lt;body&gt;
  &lt;!--MVVM中的V--&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!--渲染今天天气真好--&gt;
    &lt;p&gt;{{ msg }}&lt;/p&gt;
    &lt;button @click=&quot;show&quot;&gt;&lt;/button&gt;
  &lt;/div&gt;

  &lt;script&gt;
    var vm = new Vue({  //MVVM中的VM
      el: &quot;#app&quot;,  //控制哪块的内容
      data: {  //MVVM中的M
        msg: &quot;今天天气真好&quot;
      }，
      methods: {  //定义了当前vue实例中所有可用的方法
        show(){  //点击按钮显示msg的方法
          alert(this.msg);  //在vm中获取data里的数据需 this. 出来
        }
      }
    });
  &lt;/script&gt;
&lt;/body&gt;
</code></pre></div><ul><li><a href="https://cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener noreferrer">Vue的基本指令<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <hr> <h2 id="过滤器"><a href="#过滤器" class="header-anchor">#</a> 过滤器</h2> <ul><li><p>Vue.js允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器只能用在两个地方: <strong>mustache</strong>(插值表达式)和<strong>v-bind</strong>表达式。过滤器应该被添加到JavaScript表达式的尾部，由 “管道” 符指示；过滤器采用就近调用原则；</p></li> <li><p>过滤器调用格式</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
  &lt;!--可以接多个过滤器--&gt;
  &lt;p&gt;{{ data | 过滤器名称(...) | ... }}&lt;/p&gt;
&lt;/div&gt;
</code></pre></div><ul><li>过滤器定义语法(全局)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
  Vue.filter('过滤器名称',function (data, ...) {  //可以传多个参数
    // 第一个参数为调用格式中的data
    // 其他参数为  过滤器名称(...)  中的参数
  });
&lt;/script&gt;
</code></pre></div><ul><li>过滤器定义语法(局部/私有)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
  new Vue({
    filters: { 
      过滤器名称:  function (data, ...) {
        ...
      }
    }
  });
&lt;/script&gt;
</code></pre></div><hr> <h2 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h2> <ul><li><a href="https://www.cnblogs.com/aaronthon/p/9225943.html" target="_blank" rel="noopener noreferrer">v-model修饰符、按键修饰符、事件修饰符、系统修饰符<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>;</li> <li>自定义全局按键修饰符:</li></ul> <blockquote><p>Vue.config.keyCodes.自定义键名称 = <a href="https://www.cnblogs.com/yiven/p/7118056.html" target="_blank" rel="noopener noreferrer">按键键码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>;</p></blockquote> <hr> <h2 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h2> <ul><li>创建:</li></ul> <blockquote><p>Vue.directive('指令名称'， {
...<a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener noreferrer">钩子函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
})</p></blockquote> <ul><li>使用:</li></ul> <blockquote><p></p></blockquote> <ul><li>局部:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
  new Vue({
    directives: { 
      '指令名称': {
        ...钩子函数
      }
    }
  });
&lt;/script&gt;
</code></pre></div><ul><li>常用的钩子函数:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
  bind: function (el, ...) {  //el为引用的这个自定义指令的标签
    //常用于处理样式(css)
  },
  inserted: function () {
    //常用于处理逻辑问题(js)
  },
  update: function () {
    //
  }
}
</code></pre></div><hr> <h2 id="生命周期函数-钩子-事件"><a href="#生命周期函数-钩子-事件" class="header-anchor">#</a> 生命周期函数(钩子/事件)</h2> <p><strong>所有生命周期函数与el、data、methods同级</strong></p> <h3 id="实例创建阶段"><a href="#实例创建阶段" class="header-anchor">#</a> 实例创建阶段:</h3> <p><img src="https://upload-images.jianshu.io/upload_images/17912672-e40c4f68e1579f76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例创建阶段"></p> <ul><li>beforeCreate () {}</li></ul> <blockquote><p>它在执行时，data和methods中的数据还未初始化；</p></blockquote> <ul><li>created () {}</li></ul> <blockquote><p>它在执行时，data和methods中的数据已经初始化；</p></blockquote> <ul><li>beforeMount() {}</li></ul> <blockquote><p>它在执行时，模板已经在内存中编辑完成了，但尚未将其渲染到页面当中；</p></blockquote> <ul><li>mounted() {}</li></ul> <blockquote><p>它在执行时，模板已经渲染到页面当中了；</p></blockquote> <h3 id="实例运行阶段"><a href="#实例运行阶段" class="header-anchor">#</a> 实例运行阶段:</h3> <p><img src="https://upload-images.jianshu.io/upload_images/17912672-c5da092457dc84f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行阶段"></p> <ul><li>beforeUpdata () {}</li></ul> <blockquote><p>它在执行时，数据已经发生了改变，但没有被更新渲染到页面当中(VM未同步)；</p></blockquote> <ul><li>updata () {}</li></ul> <blockquote><p>它在执行时，新数据已经被更新渲染到页面当中了(VM已同步)；</p></blockquote> <h3 id="实例销毁阶段"><a href="#实例销毁阶段" class="header-anchor">#</a> 实例销毁阶段:</h3> <p><img src="https://upload-images.jianshu.io/upload_images/17912672-194c8697d6f89725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="销毁阶段"></p> <ul><li>beforeDestroy () {}</li></ul> <blockquote><p>它在执行时，Vue实例已经从运行阶段进入销毁阶段，但methods、data、过滤器、指令...，都处于可用状态；</p></blockquote> <ul><li>destroyed () {}</li></ul> <blockquote><p>它在执行时，Vue实例已经被完全销毁；</p></blockquote> <hr> <h2 id="vue-resource实现get、post、jsonp请求"><a href="#vue-resource实现get、post、jsonp请求" class="header-anchor">#</a> <a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener noreferrer">vue-resource<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>实现get、post、jsonp请求</h2> <ul><li><p>config、body和errorCallback都是可选属性，但config、body不可省略，如果没有需创建空对象{ }；</p></li> <li><p>全局配置数据接口根域名：</p></li></ul> <blockquote><p>Vue.http.options.root = '根域名';</p></blockquote> <p>或</p> <div class="language- extra-class"><pre class="language-text"><code>http: {
    root: '/root'
}
</code></pre></div><blockquote><p>注意: 如配置过根域名后，get、post、jsonp请求方法的url应该为除根域名的相对路径；</p></blockquote> <ul><li>GET</li></ul> <blockquote><p>get(url, [config])</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// url为请求地址，config为配置对象，successCallback为成功回调
this.$http.get('/someUrl', [config]).then(successCallback, errorCallback); 
</code></pre></div><ul><li>POST</li></ul> <blockquote><p>post(url, [body], [config])</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// url为请求地址，body是传送的数据，config为配置对象
// successCallback为成功回调
this.$http.post('/someUrl', [body], [config]).then(successCallback, errorCallback); 
</code></pre></div><blockquote><p>注意: 手动发起的post请求默认没有表单格式，所以有的服务器处理不了，这时就需要进入配置对象配置相应的对象，如，开启表单格式请求的对象为{ emulateJSON: true; }</p></blockquote> <ul><li>JSONP</li></ul> <blockquote><p>jsonp(url, [config])</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// url为请求地址，config为配置对象，successCallback为成功回调
this.$http.jsonp('/someUrl', [config]).then(successCallback, errorCallback); 
</code></pre></div><blockquote><p>JSONP实现原理
1.由于浏览器的安全性限制，不允许AJAX跨域请求(协议不同、域名不同、端口号不同 的数据接口)，浏览器认为这种访问不安全；
2.可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP；</p></blockquote> <hr> <h2 id="过渡-动画"><a href="#过渡-动画" class="header-anchor">#</a> <a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener noreferrer">过渡&amp;动画<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <ul><li>过渡类名
<img src="https://upload-images.jianshu.io/upload_images/17912672-6d992130ea2164fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过渡类名"></li></ul> <blockquote><p>v-enter：表示进入过渡的初始阶段；
v-enter-to：表示进入过渡的完成阶段；
v-leave：表示离开过渡的初始阶段；
v-leave-to：表示离开过渡的完成阶段；
v-enter-active和v-leave-active：分别表示进入和离开过渡的生效时间段；</p></blockquote> <ul><li>第三方插件辅助transition的过渡&amp;动画</li></ul> <ol><li><a href="http://www.animate.net.cn/" target="_blank" rel="noopener noreferrer">animate.css<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
animate.css提供了一套完整的过渡动画，我们只需要写入相应的类名就可以看到相应的过渡动画，但类名中需要写入基本类名animated ;</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;transition enter-active-class=&quot;animated ...&quot; leave-active-class=&quot;animated ...&quot;&gt;
  &lt;p&gt;...&lt;/p&gt;
&lt;/transition&gt;
</code></pre></div><p>或者将基本类animated加到子元素身上</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;transition enter-active-class=&quot;...&quot; leave-active-class=&quot;...&quot;&gt;
  &lt;p class=&quot;animated&quot;&gt;...&lt;/p&gt;
&lt;/transition&gt;
</code></pre></div><ol start="2"><li><a href="https://www.bootcss.com/" target="_blank" rel="noopener noreferrer">bootrap.css<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
使用:duration=&quot;ms&quot;控制进入和离开过渡的时间</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;transition enter-active-class=&quot;...&quot; leave-active-class=&quot;...&quot; :duration=&quot;300&quot;&gt;
  &lt;p class=&quot;animated&quot;&gt;...&lt;/p&gt;
&lt;/transition&gt;
</code></pre></div><p>或者使用:duration=&quot;{ enter: ms, leave: ms }&quot;可以分开控制进入和离开过渡的时间</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;transition enter-active-class=&quot;...&quot; leave-active-class=&quot;...&quot; :duration=&quot;{ enter: 200, leave: 500 }&quot;&gt;
  &lt;p class=&quot;animated&quot;&gt;...&lt;/p&gt;
&lt;/transition&gt;
</code></pre></div><ul><li><a href="https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener noreferrer">半场过渡动画生命周期事件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>vue把一整场过渡动画分为两个半场，分别为<strong>入场过渡动画</strong>和<strong>离场过渡动画</strong>，而每个半场都有自己相对应的生命周期事件，并且这些生命周期事件会作为普通事件一样用 v-on: 被绑定在 transition 标签上，事件函数也写在 methods 中；</p> <blockquote><p><strong>入场过渡动画</strong> &amp; <strong>离场过渡动画</strong>
如何绑定：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;transition
  v-on:before-enter=&quot;beforeEnter&quot;  &lt;!--入场过渡动画开始之前--&gt;
  v-on:enter=&quot;enter&quot;  &lt;!--入场过渡动画进行时--&gt;
  v-on:after-enter=&quot;afterEnter&quot;  &lt;!--入场过渡动画结束后--&gt;
  v-on:enter-cancelled=&quot;enterCancelled&quot;  &lt;!--入场过渡动画取消(不常用)--&gt;

  v-on:before-leave=&quot;beforeLeave&quot; &lt;!--离场过渡动画开始前--&gt;
  v-on:leave=&quot;leave&quot;  &lt;!--离场过渡动画进行时--&gt;
  v-on:after-leave=&quot;afterLeave&quot;  &lt;!--离场过渡动画结束后--&gt;
  v-on:leave-cancelled=&quot;leaveCancelled&quot;  &lt;!--离场过渡动画取消(不常用)--&gt;
&gt;

  ...

&lt;/transition&gt;
</code></pre></div><blockquote><p><strong>入场过渡动画</strong> &amp; <strong>离场过渡动画</strong>
事件函数：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>methods: {  //el的用法与自定义指令相同，el就是引用它那个标签
  beforeEnter (el) { ... },
  enter (el, done) { 

    el.offsetWidth;  //这句代码本身没有什么意义，但它会让过渡动画进行强制刷新，使动画减少不必要的bug;
 
    done();   //done() 相当于在enter()结束前调用了一下afterEnter()，使afterEnter()执行的更快；

  },
  afterEnter (el) { ... }
  
  ...
}
</code></pre></div><ul><li>transition-group列表过渡动画</li></ul> <blockquote><p>与 transition 标签类似的标签，它将有 v-for 和 :key 的标签包裹，所以相当于是包裹了很多个标签，而 transition 只能包裹一个标签</p></blockquote> <blockquote><p>配合过渡类名v-enter、v-enter-to、v-enter-active、v-leave-active和v-move使用</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>/* 这是一个关于离场过渡的固定写法，此外 v-leave-active这样写还不够，
还需将列表元素的width设置一个值(一般设置100%)，不然就会出现一些bug*/

.v-move{
  transition: all xx ease;
}

.v-leave-active{
  position: absolute;
}
</code></pre></div><blockquote><p>给 transition-group 添加 appear 属性可以实现列表在网页刚渲染时的过渡动画；
添加 tag=&quot;xxx&quot; 可以使 transition-group 标签在渲染时，渲染成自己设置的标签；</p></blockquote> <hr> <h2 id="vue组件"><a href="#vue组件" class="header-anchor">#</a> Vue组件</h2> <p>什么是组件：组件的出现是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块；将来，我们需要什么样的功能，就可以去调用相应的组件；</p> <h3 id="组件化与模块化的不同："><a href="#组件化与模块化的不同：" class="header-anchor">#</a> 组件化与模块化的不同：</h3> <ul><li>模块化：是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li> <li>组件化：是从 UI 界面的角度进行划分的；前端的组件化，方便 UI 组件的重用；</li></ul> <h3 id="创建组件的方法："><a href="#创建组件的方法：" class="header-anchor">#</a> 创建组件的方法：</h3> <ul><li>方法一(Vue.extend)：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// html引用
// &lt;my-com1&gt;&lt;/my-com1&gt;

var com1 = Vue.extend({  // 创建了一个模板对象的组件
  template: '&lt;h1&gt;这是使用Vue.extend创建的组件&lt;/h1&gt;'
});
Vue.component('myCom1', com1);

// 或者

Vue.component('myCom1', Vue.extend({  // 创建了一个模板对象的组件
  template: '&lt;h1&gt;这是使用Vue.extend创建的组件&lt;/h1&gt;'
}));
</code></pre></div><blockquote><p>注意: Vue.component创建组件名称时，如果使用的是驼峰命名，那么html引用该组件时，需将其单词与单词之间以 - 隔开，并为小写；如创建组件名称本就为小写创建则不需注意，直接以名称引用；</p></blockquote> <ul><li>方法二(字面量)：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('myCom1', {  // 创建了一个模板对象的组件
  template: '&lt;div&gt;&lt;p&gt;...&lt;/p&gt;&lt;h1&gt;这是使用Vue.extend创建的组件&lt;/h1&gt;&lt;/div&gt;'
});
</code></pre></div><blockquote><p>注意: 不论是哪种方式创建组件，template属性指向的模板内容，必须只有唯一的根元素才能显示更多内容；</p></blockquote> <ul><li>方法二改(template)：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 在被Vue控制的html内容外，创建tmplate的内容，并且遵循tmplate内容注意事项，
之后还需要在Vue控制的内容元素内引用才能显示内容；
&lt;template id=&quot;tmp1&quot;&gt;
  &lt;div&gt;
    &lt;p&gt;...&lt;/p&gt;
    &lt;span&gt;...&lt;/span&gt;
    ...
  &lt;/div&gt;
&lt;/template&gt;

Vue.component('myCom1', {  // 创建了一个模板对象的组件
  template: '#tmp1'
});
</code></pre></div><ul><li>方法三(局部)：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 只能在当前Vue中使用
new Vue({
  components: {
    myCom1: {  // 引用时注意驼峰事项
       template: '#tmp1'
    }
  }
});
</code></pre></div><h3 id="组件中的data："><a href="#组件中的data：" class="header-anchor">#</a> 组件中的data：</h3> <p>组件中的data与Vue实例中的data使用和引用方法一样，但创建方法不同；组件中data属性需要是一个函数，函数返回一个对象，对象中就是data中的数据；</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('myCom1', {  // 创建了一个模板对象的组件
  template: '&lt;div&gt;{{ msg }}&lt;/div&gt;'，
  data: function () {
    return {
      msg: '我是组件中的data属性'
    };
  }
});
</code></pre></div><h3 id="多个组件的切换-过渡动画"><a href="#多个组件的切换-过渡动画" class="header-anchor">#</a> 多个组件的切换&amp;过渡动画</h3> <p>Vue提供了 component 标签帮助我们进行多个组件之间的切换；</p> <ul><li>component 标签使用方法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;

  &lt;input type=&quot;button&quot; value=&quot;mycom1&quot; @click=&quot;comName='mycom1'&quot;&gt;
  &lt;input type=&quot;button&quot; value=&quot;mycom2&quot; @click=&quot;comName='mycom2'&quot;&gt;
  &lt;input type=&quot;button&quot; value=&quot;mycom3&quot; @click=&quot;comName='mycom3'&quot;&gt;
  &lt;!--这里组件的名称使用了 ' ' 单引号包起来,
  因为 :is 会将没有用单引号包裹起来的组件名称当做一个变量，
  当然 :is 当中可以传入一个变量，这样就可以实现组件的切换--&gt;
  &lt;!--&lt;component :is=&quot;'mycom1'&quot;&gt;&lt;/component&gt;--&gt;
  &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;

&lt;/div&gt;


Vue.component('mycom1',{
  template: '&lt;p&gt;组件1&lt;/p&gt;'
 });

Vue.component('mycom2',{
  template: '&lt;p&gt;组件2&lt;/p&gt;'
 });

Vue.component('mycom3',{
  template: '&lt;p&gt;组件3&lt;/p&gt;'
 });

new Vue({
  el: &quot;#app&quot;,
  data: {
    comName: ''
  }
 });
</code></pre></div><ul><li>多个组件的过渡动画
多个组件的过渡简单很多，我们不需要使用 key 属性。相反，我们只需要使用 transition 标签；没有其他注意事项；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;transition&gt;
  &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
&lt;/transition&gt;
</code></pre></div><h3 id="父亲组件向子组件传值"><a href="#父亲组件向子组件传值" class="header-anchor">#</a> 父亲组件向子组件传值</h3> <blockquote><p>1.传递data数据(green)：
<img src="https://upload-images.jianshu.io/upload_images/17912672-3ab682b81a2748ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父组件向子组件传递data数据"></p></blockquote> <p>如果Vue实例中 components(局部创建) 的组件(子组件)想获取Vue实例中 data 的数据(父组件)，那么直接输入 data 中的数据是获取不到的；我们只能通过在子组件标签上 v-bind: 绑定一个自定义属性名，然后将 data 中需要的数据传入到其中，并且需要在子组件中创建一个props数组，将自定义属性名定义一下，才能在组件中靠这个自定义属性名获取数据；</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!--其中datamsg为自定义属性名，msg为data中的数据--&gt;
&lt;mycom v-bind:datamsg=&quot;msg&quot;&gt;&lt;/mycom&gt;

new Vue({
  el: &quot;&quot;,
  data: {
    msg: &quot;111111&quot;
  },
  components: {
    mycom: {
      template: '&lt;div&gt;{{ datamsg }}&lt;/div&gt;',  //这样这个div中输出的就会是data中的msg内容
      props: [ 'datamsg' ]  //这一步在mycom中定义了datamsg，所以在template中才可以使用datamsg
    }
  }
});
</code></pre></div><ul><li>components(局部创建) 中 data 与 props 的区别
<strong>data 中的数据是可读写的，而 props 中的数据不能赋值，只读；</strong></li></ul> <blockquote><p>2.传递函数数据(green)&amp;子组件向父组件传递data数据(skyblue)：
<img src="https://upload-images.jianshu.io/upload_images/17912672-603173a182b5e7a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父组件给子组件传递函数数据"></p></blockquote> <hr> <h2 id="vue内置组件"><a href="#vue内置组件" class="header-anchor">#</a> Vue内置组件</h2> <ol><li>template标签：
模板组件，可以写一些html内容，然后引用到html中；</li> <li>transition标签：
动画组件，可以实现内容的过渡动画；</li> <li>transition-groud标签：
列表动画组件，可以实现列表的过渡动画；</li> <li>comonent标签：
辅助切换组件，帮助自定义的组件进行切换&amp;过渡；</li></ol> <hr> <h2 id="使用ref获取dom元素和组件引用"><a href="#使用ref获取dom元素和组件引用" class="header-anchor">#</a> 使用ref获取DOM元素和组件引用</h2> <p>引用( reference )</p> <ul><li>Vue提供了 $ref 这个属性，它可以在标签元素上定义一下，然后就可以在实例中获取此标签元素，当然在组件上定义也行;
定义方法：</li></ul> <blockquote><p>ref=&quot;自定义名称&quot;</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;h1 ref=&quot;apph1&quot;&gt;我是app中的h1标签&lt;/h1&gt;

&lt;mycom ref=&quot;mycom&quot;&gt;&lt;/mycom&gt;
</code></pre></div><p>获取方法：</p> <blockquote><p>this.$refs.自定义名称.获取属性</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>this.$refs.apph1.innerText  // 这是获取标签元素里的内容

this.$refs.mycom.func()  // 这是获取组件上的方法
</code></pre></div><hr> <h2 id="ue-router"><a href="#ue-router" class="header-anchor">#</a> ue-router</h2> <blockquote><p><a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener noreferrer">我在github官网下载的vue-router<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，然后将vue-router.js文件用script的方式引入到html中练习；
如果是模块开发，就需要使用到npm进行安装；</p></blockquote> <h3 id="在vue中使用vue-router"><a href="#在vue中使用vue-router" class="header-anchor">#</a> 在vue中使用vue-router</h3> <ol><li>导入 vue-router.js 文件；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;./lib/vue-router.js&quot;&gt;&lt;/script&gt;
</code></pre></div><ol start="2"><li>使用 router-link(vue-router提供) 标签来导航或者 a 标签；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登陆&lt;/router-link&gt;
&lt;router-link to=&quot;/register&quot; tag=&quot;span&quot;&gt;注册&lt;/router-link&gt;

&lt;a href=&quot;#/login&quot;&gt;登陆&lt;/a&gt;
&lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt;
</code></pre></div><ol start="3"><li>使用 router-view 来显示在 routes 中匹配到的对应的 component 组件；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-view&gt;&lt;/router-view&gt;
</code></pre></div><ol start="4"><li>创建对应组件；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var login = {
  template: '&lt;h1&gt;登陆组件&lt;/h1&gt;'
}

var register= {
  template: '&lt;h1&gt;注册组件&lt;/h1&gt;'
}
</code></pre></div><p>4.1 通过 $route.query 获取 url 中的一些简单数据；</p> <div class="language- extra-class"><pre class="language-text"><code>// 假如url中有一些数据
&lt;router-link to=&quot;/login?id=250&quot;&gt;登陆&lt;/router-link&gt;

var login = {
  //  id---250
  template: '&lt;div&gt;id---this.$route.query.id&lt;/div&gt;'
}
</code></pre></div><ol start="5"><li>创建一个 router 实例，通过 routes 属性来定义路由器匹配规则；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var routerObj = new VueRouter({
  routes: [
    { path: '/login', component: login },
    { path: '/register', component: register}
  ]
});
</code></pre></div><p>5.1 使用 redirect 属性强制让用户进入页面时跳转到某个页面(设置默认显示页面)；</p> <div class="language- extra-class"><pre class="language-text"><code>{ path: '/', redirect : '/login'}
</code></pre></div><p>5.2 通过配置与 routes 同级的 linkActiveClass 配置项，来给导航元素设置高亮( 被选中时的样式 )；注意: 类名在激活 router 实例时就已经被赋予到导航上去了，即在页面中，被选中的导航元素上会被赋予该类名；</p> <div class="language- extra-class"><pre class="language-text"><code>linkActiveClass: 'myactive'  // 默认类名为 router-link-active 
</code></pre></div><p>5.3 通过配置与 path 同级的 children 属性，来给某一个根目录添加数个子目录；</p> <div class="language- extra-class"><pre class="language-text"><code>{  
  path: '/account',
  component: account,
  children: [
    { path: 'login', component: login },
    { path: 'register', component: register }
  ]
}
</code></pre></div><p>5.4 给 router-view 标签命名，并给一个路由匹配规则添加 components 属性，实现一个路径下多个组件；</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;
&lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt;
&lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;

{
  path: '/',
  components: {
      'header': header,
      'left': left,
      'main': main
    }
  }
</code></pre></div><ol start="6"><li>使用 router 属性来使用路由规则(注册到vue实例中)；</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var vm = new Vue({
  el: &quot;#app&quot;,
  router: routerObj
});
</code></pre></div><hr> <h2 id="vue实例中的配置项"><a href="#vue实例中的配置项" class="header-anchor">#</a> vue实例中的配置项</h2> <ol><li><p>el: ''
用于规定一个vue实例管理的区域，如我需要<strong>管理</strong>一个id为app的div，el: '#app'</p></li> <li><p>data: {}
用于<strong>存放</strong>区域中的所有数据；</p></li> <li><p>methods: {}
用于<strong>存放</strong>区域内的所有函数方法，侧重于业务逻辑；</p></li> <li><p>watch: {}
用于<strong>监听</strong>区域内某些<strong>特定数据</strong>的变化，从而进行某些具体的业务逻辑操作，一般与路由结合使用；</p></li> <li><p>compnents: {}
用于<strong>挂载</strong>多个局部组件；</p></li> <li><p>router: obj
用于<strong>挂载</strong>一个路由实例；</p></li> <li><p>computed: {}
用于<strong>定义</strong>多个<strong>计算属性</strong>，计算属性的本质为一个 function ，但在其使用时，只作为一个属性使用；</p></li> <li><p>render(createElements){}
createElements 是一个方法，调用该方法可以将el管理的区域替换成指定的组件模板；该属性的特性与 v-text 相似，都会将旧内容覆盖，而且不容易被修改，操作性小；</p></li></ol> <h2 id="vuex"><a href="#vuex" class="header-anchor">#</a> VUEX</h2> <p>Vuex，是一个全局的共享数据存储区域，相当于一个数据仓库；</p> <ul><li>NPM 安装；</li></ul> <blockquote><p>npm i vuex -S</p></blockquote> <ul><li>导入 + 手动安装；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
</code></pre></div><ul><li>创建 vuex 实例；
vuex 创建实例的方法与 VueRouter 一致；
与 Vue 实例也相似；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var store = new Vuex.Store({
  state: {  // state 属性相当于 Vue 实例中的 data 属性
     num: 0
  },
  mutations: {   // mutations属性相当于 Vue 实例中的 methods 属性
   方法名 (state) {    // state 表示可以操作 state 中的数据
       state.num
      //  (state) 中只能传递两个参数，第一个为 state 第二个可以是一个对象，一个方法，一个任意参数
    }
  }
})
</code></pre></div><blockquote><p>注意：state 中的数据如果需要被操作，推荐使用 mutations 来操作，不推荐直接在组件中操作；</p></blockquote> <ul><li>挂载 vuex 到 vue 实例中；
挂载方法也跟 vue-router 挂载方法一样：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  data: {},
  methods: {},
  router,
  store  // 挂载 vuex 实例
})
</code></pre></div><blockquote><p>当挂载了 vuex 实例后，就可以调用其中的数据了:</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// 挂载前
this.$store.state.数据名
this.$store.commit('方法名')
// 挂载后
$store.state.数据名
$store.commit('方法名')
</code></pre></div><ul><li>getters 属性；
与 state 同级；作用是对外提供数据；
使用方法为：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>getters: {  // 类似于计算属性 computed

  自定义名称: function (state) {  // 与过滤器Vue.filter相似
    return ...
  }

  // 简化写法
  自定义名称(state){ 
    return ...
  }

}
</code></pre></div><p>调用方法：</p> <div class="language- extra-class"><pre class="language-text"><code>$store.getters.自定义名
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.160748f8.js" defer></script><script src="/assets/js/2.c27d8c9e.js" defer></script><script src="/assets/js/6.7f9d2657.js" defer></script>
  </body>
</html>
